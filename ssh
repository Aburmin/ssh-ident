#!/usr/bin/python

"""Wrapper around ssh to prepare ssh-agent and load identities.

Use this script instead of ssh. It will:

1) Check the arguments provided to ssh and the current working
   directory against a list of patterns defined in the
   ~/.ssh-ident configuration file.

2) Based on those patterns, the script will determine an ssh-agent
   to use, and a list of keys that need to be loaded in the agent.

3) It will then run ssh as usual, with the correct enviornment
   variables set.

This allows to start agents and load keys on demand, when they are
first needed.

Example of use
==============

In .bashrc, I have:
  alias ssh=/home/ccontavalli/scripts/ssh-ident

In ~/.ssh-ident, I have:

  MATCH_PATH = [
    (r"mod-xslt", "personal"),
    (r"ssh-ident", "personal"),
    (r"opt/work", "work"),
  ]
  
  MATCH_ARGV = [
    (r"cweb", "personal"),
    (r"corp", "work"),
  ]

  DEFAULT_IDENTITY = "personal"

Now if I run:

  ssh corp.mywemployer.com

ssh-ident will be invoked instead, and:

  1) check ssh argv, determine that the "work" identity has to be used.
  2) look in ~/.ssh/agents, for a "work" agent loaded. If there is no
     agent, it will prepare one.
  3) look in ~/.ssh/identities/work/* for a list of keys to load for
     this identity. It will try to load any key that is not already
     loaded in the agent.
  4) finally run ssh with the environment setup such that it will
     have access only to the agent for the identity work, and the
     corresponding keys.

Setting up identities
=====================

To setup identities with the default parameters, you should:

1) Create the directory where all the identities and agents
   will be kept:

    $ mkdir -p ~/.ssh/{agents,identities}; chmod u=rwX,go= -R ~/.ssh

2) Create identities, for example:

    $ mkdir -p ~/.ssh/identities/personal
    $ mkdir -p ~/.ssh/identities/work
    $ mkdir -p ~/.ssh/identities/secret

3) Generate (or copy) keys for those identities:

    # Default keys are for my personal account
    $ cp ~/.ssh/id_rsa* ~/.ssh/identities/personal

    # Generate keys to be used for work only, rsa
    $ ssh-keygen -t rsa -b 4096 -f ~/.ssh/identities/work/rsa-key

    ...

Note that ssh-ident needs to access both your private and public
key. Note also that it identifies public keys by the .pub extension.
All files in your identities subdirectories will be considered keys.

If you want to only load keys that have "key" in the name, you can
add in your .ssh-ident:

      PATTERN_KEYS = "*key*"

The default is PATTERN_KEYS = "*". You could also redefine:

      DIR_IDENTITIES = "$HOME/.ssh/identities"
      DIR_AGENTS = "$HOME/.ssh/agents"

To point somewhere else if you desire.
"""

import glob
import sys
import os
import re
import socket
import subprocess
import collections


class Config(object):
  defaults = {
      # Where to find the per-user configuration.
      "FILE_USER_CONFIG": "$HOME/.ssh-ident",

      # Where to find all the identities for the user.
      "DIR_IDENTITIES": "$HOME/.ssh/identities",
      # Where to keep the information about each running agent.
      "DIR_AGENTS": "$HOME/.ssh/agents",

      # How to identify key files in the identities directory.
      "PATTERN_KEYS": "*",
      # Complete path of full ssh binary to use.
      "BINARY_SSH": "/usr/bin/ssh",

      # Which identity to use by default if we cannot tell from
      # the current working directory and/or argv. 
      "DEFAULT_IDENTITY": "$USER",

      # Those should really be overridden by the user. Look
      # at the documentation for more details.
      "MATCH_PATH": [],
      "MATCH_ARGV": [],
  }

  def __init__(self):
    self.values = {}

  def Load(self):
    path = self.Get("FILE_USER_CONFIG")
    variables = {}
    try: 
      execfile(path, {}, variables)
    except IOError:
      print >>sys.stderr, "Warning: could not load config '%s', you might as well be using plain ssh." % path
      return self
    self.values = variables
    return self

  @staticmethod
  def Expand(value):
    if isinstance(value, str):
      return os.path.expanduser(os.path.expandvars(value))
    return value
 
  def Get(self, parameter):
    if parameter in self.values:
      return self.Expand(self.values[parameter])
    if parameter in self.defaults:
      return self.Expand(self.defaults[parameter])

    print >>sys.stderr, (
        "Parameter '%s' needs to be defined in "
        "config file or defaults" % parameter)
    sys.exit(2)

def FindIdentityInList(elements, identities):
  """Matches a list of identities to a list of elements.

  Args:
    elements: iterable of strings, arbitrary strings to match on.
    identities: iterable of (string, string), with first string
      being a regular expression, the second string being an identity.

  Returns:
    The identity specified in identities for the first regular expression
    matching the first element in elements.
  """
  for element in elements:
    for regex, identity in identities:
      if re.search(regex, element):
        return identity
  return None

def FindIdentity(argv, config):
  """Returns the identity to use based on current directory or argv.

  Args:
    argv: iterable of string, argv passed to this program.
    config: instance of an object implementing the same interface as
        the Config class.

  Returns:
    string, the name of the identity to use.
  """
  paths = set([os.getcwd(), os.path.abspath(os.getcwd()), os.path.normpath(os.getcwd())])
  return (
      FindIdentityInList(argv, config.Get("MATCH_ARGV")) or
      FindIdentityInList(paths, config.Get("MATCH_PATH")) or
      config.Get("DEFAULT_IDENTITY"))

def FindKeys(identity, config):
  keyfiles = glob.glob(os.path.join(
      config.Get("DIR_IDENTITIES"), identity, config.Get("PATTERN_KEYS")))

  found = collections.defaultdict(dict)
  for key in keyfiles:
    kinds = (
        ("private", "priv"),
        ("public", "pub"),
        (".pub", "pub"),
        ("", "priv"),
    )
    for pattern, kind in kinds:
      if pattern in key:
        found[key.replace(pattern, "")][kind] = key
  
  if not found:
    print "Warning: no keys found for identity %s" % identity
  return found 

class AgentManager(object):
  def __init__(self, identity, config):
    self.identity = identity
    self.config = config
    self.agents_path = os.path.abspath(config.Get("DIR_AGENTS"))
    self.agent_file = self.GetAgentFile(self.agents_path, self.identity)

  def LoadUnloadedKeys(self, keys):
    toload = self.FindUnloadedKeys(keys)
    if toload:
      print "Loading keys:\n    %s" % "\n    ".join(toload)
      self.LoadKeyFiles(toload)
    else:
      print "All keys already loaded"

  def FindUnloadedKeys(self, keys):
    loaded = set(self.GetLoadedKeys())
    toload = set()
    for key, config in keys.iteritems():
      if "pub" not in config:
        continue
      if "priv" not in config:
        continue

      fingerprint = self.GetPublicKeyFingerprint(config["pub"])
      if fingerprint in loaded:
        continue

      toload.add(config["priv"])
    return toload

  def LoadKeyFiles(self, keys):
    keys = " ".join(keys)
    self.RunShellCommandInAgent(self.agent_file, "ssh-add %s" % keys)

  def GetLoadedKeys(self):
    retval, stdout = self.RunShellCommandInAgent(self.agent_file, "ssh-add -l")
    if retval != 0:
      return []

    fingerprints = []
    for line in stdout.split("\n"):
      try:
        _, fingerprint, _ = line.split(" ", 2)
        fingerprints.append(fingerprint)
      except ValueError:
        continue
    return fingerprints

  @staticmethod
  def GetPublicKeyFingerprint(key):
    retval, stdout = AgentManager.RunShellCommand("ssh-keygen -l -f %s |tr -s ' '" % key)
    if retval:
      return None

    try:
      _, fingerprint, _ = stdout.split(" ", 2)
    except ValueError:
      return None
    return fingerprint

  @staticmethod
  def GetAgentFile(path, identity):
    # Use the hostname as part of the path just in case this is on NFS.
    agentfile = os.path.join(path, "agent-%s-%s" % (identity, socket.gethostname()))
    if os.access(agentfile, os.R_OK) and AgentManager.IsAgentFileValid(agentfile):
      print >>sys.stderr, "Agent for identity %s ready" % identity
      return agentfile

    print >>sys.stderr, "Preparing new agent for identity %s" % identity
    retval = subprocess.call(
        ["/usr/bin/env", "-i", "/bin/sh", "-c", "ssh-agent > %s" % agentfile])
    return agentfile

  @staticmethod
  def IsAgentFileValid(agentfile):
    retval, output = AgentManager.RunShellCommandInAgent(agentfile, "ssh-add -l >/dev/null 2>/dev/null") 
    if retval & 0xff not in [0, 1]:
      print >>sys.stderr, "Agent in %s not running" % agentfile
      return False
    return True

  @staticmethod
  def RunShellCommand(command):
    command = ["/bin/sh", "-c", command]
    process = subprocess.Popen(command, stdout=subprocess.PIPE)
    stdout, stderr = process.communicate()
    return process.wait(), stdout

  @staticmethod
  def RunShellCommandInAgent(agentfile, command):
    command = ["/usr/bin/env", "-i", "/bin/sh", "-c", ". %s >/dev/null 2>/dev/null; %s" % (agentfile, command)]
    process = subprocess.Popen(command, stdout=subprocess.PIPE)
    stdout, stderr = process.communicate()
    return process.wait(), stdout

  @staticmethod
  def EscapeShellArguments(argv):
    escaped = []
    for arg in argv:
      escaped.append("'%s'" % arg.replace("'", "'\"'\"'"))
    return " ".join(escaped)

  def RunSSH(self, argv):
    command = ["/bin/sh", "-c", ". %s >/dev/null 2>/dev/null; exec %s %s" % (
               self.agent_file, self.config.Get("BINARY_SSH"),
               self.EscapeShellArguments(argv))]
    os.execv("/bin/sh", command) 

def main(argv):
  # Replace stdout and stderr with /dev/tty, so we don't mess up with scripts
  # that use ssh in case we error out or similar.
  sys.stdout = open("/dev/tty", "w")
  sys.stderr = open("/dev/tty", "w")

  config = Config().Load()
  identity = FindIdentity(argv, config)
  agent = AgentManager(identity, config)
  keys = FindKeys(identity, config)

  agent.LoadUnloadedKeys(keys)
  return agent.RunSSH(argv[1:])

if __name__ == "__main__":
  try:
    sys.exit(main(sys.argv))
  except KeyboardInterrupt:
    print >>sys.stderr, "Goodbye"
